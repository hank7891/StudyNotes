其實網路上對SOLID的探討及見解文章已經多不勝數。筆者在此僅記錄自身見解與歷程。

若對該原則理解有誤，請不吝指教。

# SOLID?
 * 在**程式設計**的領域中，SOLID指**物件導向編成**和**物件導向設計**的五個基本原則。
 * 當這些原則一起被應用時，可以使**程式設計師**開發一個容易**擴充**及**維護**的系統。
 * SOLID所包含的原則是通過引發**編程者**進行軟體*原始碼代碼重構*的**代碼異味**清掃。從而使**軟體**清晰可讀及具可擴展性。
 * SOLID被典型的應用在**測試驅動開發**上，且是**敏捷開發**及**自適應軟體開發**的基本原則重要組成部分。


## S: Single responsibility principle(SRP) 單一職責
```
一個類別(class)/方法(method)只能負責一個職責
```

如果**一個類別做了兩件職責，就必須拆成兩個類別**。
 * 當類別包含複數職責時，則其`內聚力`越低。
 * 當類別職責越單純且清楚，則其`內聚力`越高。
 
**舉例:**

如果`汽車`與`飛機`皆為交通工具而實作於同一個`類別(super obj)`中，汽車行為模式為 `run` 而飛機行為模式為 `fly`。那該類別內部邏輯會變得**雜亂**且**難以維護**。
    
若將`汽車`與`飛機`個別實作，各自物件只要管理自己的`權責`。即可提高`內聚`。而特定邏輯修改時只要到對應物件內做調整，也降低了**維護的難易度**。
    
**結論:**
    
 * 一個 class/method 只做一件事。
 * 遵守 SPR 可為程式提高內聚。
 
## Open/close principle(OCP) 開放/封閉原則
```
程式在擴充新功能時，不更動原程式碼或者僅以最小幅度修改程式碼的開發方式。
```
 * 系統實作完若遇到新需求，必須回頭**調整原本做好的程式代碼**。而只要修改舊的代碼就可能造成`不良副作用 ` #1。應以最小的幅度來修改已存在的程式碼（`甚至不修改`)才是最佳的情況。

 * OCP 使系統保有彈性，可以**擴充新功能**。若有新需求只要進行**新增**，而不用修改到舊有程式碼(`對修改封閉`，`對新增開放`)。進而杜絕`不良副作用`的產生。
 
 * OCP 只是一個原則，讓程式變得靈活的代價是需要花費額外的時間與精力將程式引入新的抽象層，還會增加程式的複雜度。所以 OCP 原則只適合被套用於經常變更的地方！
 
(#1)不良副作用: 修改程式內碼造成其他使用的該邏輯的地方產生錯誤，即大家口中的改 A 壞 B。

**舉例:**

設計車子時，因`單一職責(SPR)`而對車上零件(車燈、輪胎、引擎)進行模組化。
若此時若想將**一般輪胎**換成**雪胎**。而去修改**一般輪胎**的模組(物件)內容，可能造成其他使用該物件的邏輯錯誤。

若遵守 `OCP` 原則，僅對輪台新增**雪胎**模組，在車子內部進行替換組合。則只需`新增`還不需要`修改`。拒絕了**改 A 壞 B**的情況產生。

**結論:**

 * 只有經常變更的地方需要使用 OCP 原則。
 * 系統對`新增開放`，`修改封閉`。

## L: Liskov substitution principle(LSP) Liskov替換
白話一點就是，我建立一個父類別，然後隨意new子類別並調用裡面任意方法。程式都該正常執行而不會出錯。


里氏替換至少擁有下列兩種含義:
1. 若繼承是為了實現**代碼重用**(**共享方法**)，那共享的父類別方法應該保持不變，不能被子被別重新定義。子類別僅能透過添加方法來擴充功能。
2. 若繼承是為了**多態**，那父類別應該以抽象方法方式，讓子類別重新定義該方法邏輯。


依車子來說，車子定義了一個動作稱為在路上跑(Run)。而建造了三台車:跑車、房車、樂高車接繼承了車子的定義。但樂高車因為沒有引擎而不能執行路上跑(Run)的動作。故他違反了里氏替換原則。子類別應該要能執行父類別任何方法。


## I: Interface Segregation Principle(ISP) 介面隔離
將不是所有人都必要的功能從介面中抽出。
若是將功能方法一股腦地寫入統一介面，可能使類別A、類別B在實作上繼承(實作)倒不必要方法。若發現有方法可能是非必要的(不是所有人都會去使用到)。可以將她拆出，形成介面隔離。


承接上述里氏替換(LSP)原則舉例舉例來說。若只要是能在車庫內展示的皆可稱為車子。那上述樂高車就不能因為不能再路上跑(Run)而不能被稱為車子。
此時可以將路上跑的功能細分拆出新定義可以跑的車(並繼承原車子定義)。此時樂高車繼承車子定義，跑車跟房車繼承可以跑的車定義。這樣三部車皆可稱之為車子。且樂高車也不會被受限於路上跑的功能。


## D: Dependency Inversion Principle(DIP) 依賴反轉
依賴反轉有以下兩項定義:

 * 高層模組不應該依賴底層模組，它們都應該依賴抽象。 
 * 抽象不應該依賴細節。細節應該依賴抽象。


即不可再套件內寫死使用的底層模組，這樣會導致程式對該模組過度依賴(只要該模組不存在程式即不能執行)。
依上述例子延生。今日要開一場車展。那不可將程式寫死，展示車輛：跑車。
這樣要是跑車被開出去不在家。那車展不就開天窗了。
倘若展示車輛：車子，那即使跑車不在。推出樂高車與房車。皆可完成車展任務(樂高車及房車皆符合車子定義:展示)。

### -------------------
工程師最怕聽到的就是程式又要改。
而SOLID原則是前人經過無數經驗統整出使程式具備容易維護且拒可擴充性質。讓之後在更動程式或擴充需求時能降低修改既有程式難易度。
雖說SOLID原則能使程式品質有實質的耀生，但還是得注意別陷入**過度設計**。

# 參考網址
[物件導向程式設計基本原則 - SOLID
](https://skyyen999.gitbooks.io/-study-design-pattern-in-java/content/oodPrinciple.html)

[【筆記】物件導向設計 : SOLID 介紹](http://wayne265265.pixnet.net/blog/post/114919277-%E3%80%90%E7%AD%86%E8%A8%98%E3%80%91%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88-%3A-solid-%E4%BB%8B%E7%B4%B9)


