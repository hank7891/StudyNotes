其實網路上對SOLID的探討及見解文章已經多不勝數。筆者在此僅記錄自身見解與歷程。

若對該原則理解有誤，請不吝指教。

# SOLID?
 * 在**程式設計**的領域中，SOLID指**物件導向編成**和**物件導向設計**的五個基本原則。
 * 當這些原則一起被應用時，可以使**程式設計師**開發一個容易**擴充**及**維護**的系統。
 * SOLID所包含的原則是通過引發**編程者**進行軟體*原始碼代碼重構*的**代碼異味**清掃。從而使**軟體**清晰可讀及具可擴展性。
 * SOLID被典型的應用在**測試驅動開發**上，且是**敏捷開發**及**自適應軟體開發**的基本原則重要組成部分。


## S: Single responsibility principle(SRP) 單一職責
```
一個類別(class)/方法(method)只能負責一個職責
```

如果**一個類別做了兩件職責，就必須拆成兩個類別**。
 * 當類別包含複數職責時，則其`內聚力`越低。
 * 當類別職責越單純且清楚，則其`內聚力`越高。
 
**舉例:**

如果`汽車`與`飛機`皆為交通工具而實作於同一個`類別(super obj)`中，汽車行為模式為 `run` 而飛機行為模式為 `fly`。那該類別內部邏輯會變得**雜亂**且**難以維護**。
    
若將`汽車`與`飛機`個別實作，各自物件只要管理自己的`權責`。即可提高`內聚`。而特定邏輯修改時只要到對應物件內做調整，也降低了**維護的難易度**。
    
**結論:**
    
 * 一個 class/method 只做一件事。
 * 遵守 SPR 可為程式提高內聚。
 
## Open/close principle(OCP) 開放/封閉原則
```
程式在擴充新功能時，不更動原程式碼或者僅以最小幅度修改程式碼的開發方式。
```
 * 系統實作完若遇到新需求，必須回頭**調整原本做好的程式代碼**。而只要修改舊的代碼就可能造成`不良副作用 ` #1。應以最小的幅度來修改已存在的程式碼（`甚至不修改`)才是最佳的情況。

 * OCP 使系統保有彈性，可以**擴充新功能**。若有新需求只要進行**新增**，而不用修改到舊有程式碼(`對修改封閉`，`對新增開放`)。進而杜絕`不良副作用`的產生。
 
 * OCP 只是一個原則，讓程式變得靈活的代價是需要花費額外的時間與精力將程式引入新的抽象層，還會增加程式的複雜度。所以 OCP 原則只適合被套用於經常變更的地方！
 
(#1)不良副作用: 修改程式內碼造成其他使用的該邏輯的地方產生錯誤，即大家口中的改 A 壞 B。

**舉例:**

設計車子時，因`單一職責(SPR)`而對車上零件(車燈、輪胎、引擎)進行模組化。
若此時若想將**一般輪胎**換成**雪胎**。而去修改**一般輪胎**的模組(物件)內容，可能造成其他使用該物件的邏輯錯誤。

若遵守 `OCP` 原則，僅對輪胎新增**雪胎**模組，在車子內部進行替換組合。則只需`新增`還不需要`修改`。拒絕了**改 A 壞 B**的情況產生。

**結論:**

 * 只有經常變更的地方需要使用 OCP 原則。
 * 系統對`新增開放`，`修改封閉`。

## L: Liskov substitution principle(LSP) Liskov替換
```
Subtypes must be substitutable for their base types.
所有子類別都可以代理父類別的工作。
```
里氏替換原則原則要能夠成立，**介面(interface)**/**抽象方法(Abstract method)** 就必須要遵守定義去實做。

 * 子類別需兌現對父類別的承諾，遵照父類別設計開發。
 
 * 作為子類別的方法必須和他們父類別的方法**操作一致**，子類別中可以擁有父類別沒有的特殊功能，但是繼承的方法，**功能應該兩者一致**的。
 
 * 子類不只是實現父類別的方法，而且必須**名符其實**，否則會發生**無法預料的事情**。

**舉例:**

`雪胎`及`一般輪胎`皆繼承`輪胎模組(父類別)`，而組裝者可由方法`取得材質(function)`取得輪胎材質來判斷是否適合組裝。若`雪胎`擅自更改回傳值為`適用地形`。就會造成組裝者誤判而產生**無法逾期之錯誤**。

若遵守 `LSP` 原則，`取得材質(function)`方法應該遵循`輪胎模組(父類別)`設計結構去回傳正確值。即可避免程式的行為變得`不可預測`。

**結論:**

 * 子類別必須遵從**父類別或介面**的**設計理念**去實作方法。
 * **LSP** 是實現 **OCP** 原則的重要方式，只有當子類別能夠`完全替代它們的父類別類`時，使用`父類別的函數`才能夠被安全的重用。


## I: Interface Segregation Principle(ISP) 介面隔離

```
Clients should not be forced to depend upon interfaces that they don’t use.
介面不應該強迫 Client 依賴於它們用不到的方法。
```

```
The dependency of one class to another one should depend on the smallest possible interface.
類別之間的相依關係應該建立在最小的介面上
```

類別與類別之間的關係，應只依賴彼此需要的`最少介面`，介面不能`太肥`，應該要`細化`。

 * 介面的目的都是提供一個讓 Client 端可以使用我們`開發模組的管道`。
 
 * 介面處於應用**程式**與**模組**之間、或是**專案**與**模組**之間，這種關係就如同`第三方套件提供服務 API 給一個網站使用`。

**舉例:**

`跑車`與`玩具車`皆繼承`汽車模組(父類別)`，而`汽車模組(父類別)`存在一方法`跑(function)`。但玩具車並不具備`跑(function)`這個行為，若是空實作則違反 `LSP` 原則。

應該設計兩`介面(interface)`:`模型車(interfece)`與`實車(interface)`。
而於`實車(interface)`內部宣告`跑(function)`方法，再由`跑車`與`玩具車`個別去實作對應的`介面(interface)`。

**結論:**

 * `ISP` 可降低**商業邏輯（低階模組）**與 **Client** 之間的耦合。
 * 設計模組時，要以 **Client** **需求的角度**建立介面，且避免設計龐多功能的單一介面。
 * 設計`介面(interface)`的時候，應該考慮**單一職責原則**，把有關聯的方法放在一起，分割出多個單一功能的介面。


## D: Dependency Inversion Principle(DIP) 依賴反轉

```
High-level modules should not depend on low-level modules. Both should depend on abstractions.
高階模組不應該依賴於低階模組，兩者都該依賴抽象。
```

```
Abstractions should not depend on details.
抽象不應該依賴細節。
```

```
Details should depend on abstractions.
低階模組的實作內容應該依照抽象的定義去實作。
```

高階與低階，是相對關係，其實也就是 **呼叫者 (Caller)** 與 **被呼叫者 (Callee)**。

 * ￼**高階模組**直接依賴**低階模組**，則為**高耦合**。
 
 * 不應該讓任何東西直接依賴**低階模組**。

 * `DIP` 由 `DI(注入)` 與 `IOC(控制反轉)` 實作。目的為`解除耦合性(解偶)`。
 
**舉例:**

實作`汽車`時需組裝`零件`，此時若將`零件`寫死於`汽車`中。若其中一項`零件`停產了或要更換。則需到`汽車`中修改既有內碼(違反 `OCP`)。

以輪胎為例，`汽車`有內碼`使用 一般輪胎`。而`一般輪胎`剛好停產或廢棄了。那`汽車`即會出錯。
若是要修改還需要到`汽車`內碼中將`使用 一般輪胎`改成`使用 新的一般輪胎`。

若依照 `DIP` 設計。將輪胎抽離於組裝者取得並組裝於車上。舉例來說`汽車->組裝輪胎(一般輪胎)`。
依上述情境若`一般輪胎`出事了，組裝者只要從外部替換輪胎`汽車->組裝輪胎(新的一般輪胎)`。
則不用更動`汽車程式內碼`，`汽車`與`輪胎`之間也不具備耦合性。

*結論:*

 * `介面(interface)`應由*高階模組*去制定規範。
 * 使用`介面(interface)`確保`低階模組`開發正確性。
 * 遵守 `DIP` 可大大降低物件之間的`耦合性(解偶)`。
 * 依賴反轉原則可以幫助我們遵守**其他原則**，遵守依賴反轉的過程中會：
    * 拆散類別的職責(`SRP`)。
    * 更容易達成 `OCP`。
    * 避免父子類別沒有依照介面的定義實作(`LSP`)。
    * 拆散介面的職責(`ISP`)。

### -------------------
工程師最怕聽到的就是程式又要改。
而SOLID原則是前人經過無數經驗統整出使程式具備容易維護且具可擴充性質。讓之後在更動程式或擴充需求時能降低修改既有程式難易度。
雖說SOLID原則能使程式品質有實質的躍升，但還是得注意別陷入**過度設計**。

# 參考網址
[物件導向程式設計基本原則 - SOLID
](https://skyyen999.gitbooks.io/-study-design-pattern-in-java/content/oodPrinciple.html)

[【筆記】物件導向設計 : SOLID 介紹](http://wayne265265.pixnet.net/blog/post/114919277-%E3%80%90%E7%AD%86%E8%A8%98%E3%80%91%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88-%3A-solid-%E4%BB%8B%E7%B4%B9)




